<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRChat OSC Controller</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf, #ff006e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .container { max-width: 1600px; margin: 0 auto; }
        
        /* çŠ¶æ€æ  */
        .status-bar {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            font-size: 0.85rem;
            z-index: 1000;
        }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: #ff4444; transition: background 0.3s; }
        .status-dot.connected { background: #00ff88; box-shadow: 0 0 8px #00ff88; }
        
        /* å¸ƒå±€ç½‘æ ¼ */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 1200px) {
            .main-grid { grid-template-columns: 1fr 1fr; }
        }
        @media (max-width: 800px) {
            .main-grid { grid-template-columns: 1fr; }
        }
        
        /* é¢æ¿é€šç”¨æ ·å¼ */
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel h2 {
            margin-bottom: 15px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel h2::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        /* åˆ†ç±»é¢œè‰² */
        .category-input h2::before { background: #00d4ff; }
        .category-input h2 { color: #00d4ff; }
        
        .category-chatbox h2::before { background: #ff006e; }
        .category-chatbox h2 { color: #ff006e; }
        
        .category-camera h2::before { background: #8338ec; }
        .category-camera h2 { color: #8338ec; }
        
        .category-system h2::before { background: #ff9f1c; }
        .category-system h2 { color: #ff9f1c; }
        
        .category-avatar h2::before { background: #00ff88; }
        .category-avatar h2 { color: #00ff88; }
        
        .category-tracking h2::before { background: #06ffa5; }
        .category-tracking h2 { color: #06ffa5; }
        
        /* è™šæ‹Ÿæ‘‡æ† */
        .joystick-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        #joystickCanvas {
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(0, 212, 255, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
            border: 2px solid rgba(0, 212, 255, 0.3);
            cursor: pointer;
            touch-action: none;
        }
        
        .joystick-values {
            display: flex;
            gap: 20px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .joystick-value { color: #00d4ff; }
        
        .quick-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .quick-btn {
            padding: 8px;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        
        .quick-btn:hover { background: rgba(0, 212, 255, 0.4); }
        .quick-btn:active { transform: scale(0.95); }
        
        /* èŠå¤©æ¡† */
        .chatbox-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .chatbox-input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 0, 110, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 60px;
        }
        
        .chatbox-input:focus {
            outline: none;
            border-color: #ff006e;
        }
        
        .chatbox-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .chatbox-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .chatbox-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(255, 0, 110, 0.4); }
        
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(255, 0, 110, 0.1);
            border-radius: 20px;
            font-size: 0.8rem;
        }
        
        .typing-dots {
            display: flex;
            gap: 3px;
        }
        
        .typing-dot {
            width: 6px;
            height: 6px;
            background: #ff006e;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
        
        /* ç›¸æœºæ§åˆ¶ */
        .camera-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .camera-mode-select {
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(131, 56, 236, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        .camera-btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .camera-btn {
            padding: 10px 16px;
            background: rgba(131, 56, 236, 0.2);
            border: 1px solid rgba(131, 56, 236, 0.3);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        
        .camera-btn:hover { background: rgba(131, 56, 236, 0.4); }
        .camera-btn.active { background: rgba(131, 56, 236, 0.6); }
        
        .camera-slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .camera-slider-label {
            font-size: 0.8rem;
            color: #888;
        }
        
        .camera-slider {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .camera-slider input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: rgba(131, 56, 236, 0.2);
            border-radius: 3px;
            outline: none;
        }
        
        .camera-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #8338ec;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .camera-slider-value {
            min-width: 50px;
            text-align: right;
            font-family: monospace;
            font-size: 0.85rem;
            color: #8338ec;
        }
        
        /* ç³»ç»Ÿä¿¡æ¯ */
        .system-info {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .system-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: rgba(255, 159, 28, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 159, 28, 0.2);
        }
        
        .system-label {
            font-size: 0.85rem;
            color: #888;
        }
        
        .system-value {
            font-family: monospace;
            font-size: 0.9rem;
            color: #ff9f1c;
        }
        
        .avatar-id {
            font-size: 0.75rem;
            word-break: break-all;
        }
        
        /* Avatarå‚æ•°é¢æ¿ */
        .params-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 1000px) {
            .params-section { grid-template-columns: 1fr; }
        }
        
        .param-grid {
            display: grid;
            gap: 10px;
            max-height: 350px;
            overflow-y: auto;
        }
        
        .param-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background 0.2s;
        }
        
        .param-item:hover { background: rgba(0, 0, 0, 0.3); }
        
        .param-name {
            font-weight: 500;
            min-width: 90px;
            font-size: 0.85rem;
        }
        
        .param-type {
            font-size: 0.65rem;
            color: #888;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .value-display {
            min-width: 35px;
            text-align: right;
            font-family: monospace;
            font-size: 0.8rem;
            color: #00d4ff;
        }
        
        .switch {
            position: relative;
            width: 44px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider-switch {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            transition: 0.3s;
            border-radius: 24px;
        }
        
        .slider-switch::before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        input:checked + .slider-switch {
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
        }
        
        input:checked + .slider-switch::before {
            transform: translateX(20px);
        }
        
        .output-value {
            min-width: 45px;
            text-align: right;
            font-family: monospace;
            font-size: 0.8rem;
            color: #00ff88;
        }
        
        .progress-bar {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            border-radius: 3px;
            transition: width 0.1s ease-out;
        }
        
        .bool-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            transition: background 0.2s;
        }
        
        .bool-indicator.active {
            background: #00ff88;
            box-shadow: 0 0 8px #00ff88;
        }
        
        /* Velocityå¯è§†åŒ– */
        .vector-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .vector-panel h2 {
            margin-bottom: 15px;
            font-size: 1.1rem;
            color: #ff6b6b;
        }
        
        .vector-display {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        #velocityCanvas {
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .vector-info {
            flex: 1;
            min-width: 180px;
        }
        
        .vector-value {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            margin-bottom: 6px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }
        
        .vector-label { color: #888; font-size: 0.85rem; }
        .vector-num { font-family: monospace; font-size: 1rem; }
        .velocity-x { color: #00d4ff; }
        .velocity-y { color: #00ff88; }
        .velocity-z { color: #ff6b6b; }
        
        /* æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); border-radius: 3px; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }
    </style>
</head>
<body>
    <div class="status-bar">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">è¿æ¥ä¸­...</span>
    </div>

    <div class="container">
        <h1>VRChat OSC Controller</h1>
        
        <!-- é¡¶éƒ¨åŠŸèƒ½åŒº -->
        <div class="main-grid">
            <!-- è™šæ‹Ÿæ‘‡æ† -->
            <div class="panel category-input">
                <h2>ğŸ® è™šæ‹Ÿæ‘‡æ† (ç§»åŠ¨æ§åˆ¶)</h2>
                <div class="joystick-container">
                    <canvas id="joystickCanvas" width="180" height="180"></canvas>
                    <div class="joystick-values">
                        <span>X: <span class="joystick-value" id="joyX">0.00</span></span>
                        <span>Y: <span class="joystick-value" id="joyY">0.00</span></span>
                    </div>
                    <div class="quick-buttons">
                        <button class="quick-btn" onmousedown="sendInput('Jump', true)" onmouseup="sendInput('Jump', false)" ontouchstart="sendInput('Jump', true)" ontouchend="sendInput('Jump', false)">è·³è·ƒ</button>
                        <button class="quick-btn" onmousedown="sendInput('Run', true)" onmouseup="sendInput('Run', false)" ontouchstart="sendInput('Run', true)" ontouchend="sendInput('Run', false)">å¥”è·‘</button>
                        <button class="quick-btn" onclick="toggleInput('Voice')">è¯­éŸ³</button>
                        <button class="quick-btn" onclick="toggleInput('AFKToggle')">AFK</button>
                        <button class="quick-btn" onclick="stopMovement()" style="background: rgba(255, 0, 0, 0.3); border-color: rgba(255, 0, 0, 0.5);">ğŸ›‘ åœæ­¢</button>
                    </div>
                </div>
            </div>
            
            <!-- èŠå¤©æ¡† -->
            <div class="panel category-chatbox">
                <h2>ğŸ’¬ Chatbox</h2>
                <div class="chatbox-container">
                    <textarea class="chatbox-input" id="chatboxText" placeholder="è¾“å…¥æ¶ˆæ¯... (Enterå‘é€)" maxlength="144"></textarea>
                    <div class="chatbox-controls">
                        <button class="chatbox-btn" onclick="sendChatbox()">å‘é€</button>
                        <div class="typing-indicator" id="typingIndicator" style="display: none;">
                            <span>è¾“å…¥ä¸­</span>
                            <div class="typing-dots">
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                            </div>
                        </div>
                        <label style="display: flex; align-items: center; gap: 5px; font-size: 0.8rem;">
                            <input type="checkbox" id="chatboxNotify" checked> é€šçŸ¥éŸ³
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- ç›¸æœºæ§åˆ¶ -->
            <div class="panel category-camera">
                <h2>ğŸ“· ç›¸æœºæ§åˆ¶</h2>
                <div class="camera-controls">
                    <select class="camera-mode-select" id="cameraMode" onchange="setCameraMode(this.value)">
                        <option value="0">å…³é—­ç›¸æœº</option>
                        <option value="1">æ‹ç…§æ¨¡å¼</option>
                        <option value="2">ç›´æ’­æ¨¡å¼</option>
                        <option value="3">è¡¨æƒ…æ¨¡å¼</option>
                        <option value="4">å¤šå±‚æ¨¡å¼</option>
                        <option value="5">æ‰“å°æ¨¡å¼</option>
                        <option value="6">æ— äººæœºæ¨¡å¼</option>
                    </select>
                    
                    <div class="camera-btn-group">
                        <button class="camera-btn" onclick="sendCameraAction('Capture')">ğŸ“¸ æ‹ç…§</button>
                        <button class="camera-btn" onclick="sendCameraAction('CaptureDelayed')">â±ï¸ å»¶æ—¶</button>
                        <button class="camera-btn" onclick="sendCameraAction('Close')">âŒ å…³é—­</button>
                    </div>
                    
                    <div class="camera-slider-container">
                        <span class="camera-slider-label">ç¼©æ”¾</span>
                        <div class="camera-slider">
                            <input type="range" min="20" max="150" value="45" id="cameraZoom" oninput="setCameraParam('Zoom', this.value)">
                            <span class="camera-slider-value" id="zoomValue">45</span>
                        </div>
                    </div>
                    
                    <div class="camera-slider-container">
                        <span class="camera-slider-label">æ›å…‰</span>
                        <div class="camera-slider">
                            <input type="range" min="-10" max="4" value="0" step="0.1" id="cameraExposure" oninput="setCameraParam('Exposure', this.value)">
                            <span class="camera-slider-value" id="exposureValue">0</span>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 5px;">
                        <label style="font-size: 0.8rem; display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" onchange="toggleCameraToggle('ShowUIInCamera', this.checked)"> æ˜¾ç¤ºUI
                        </label>
                        <label style="font-size: 0.8rem; display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" onchange="toggleCameraToggle('LocalPlayer', this.checked)"> æœ¬åœ°ç©å®¶
                        </label>
                        <label style="font-size: 0.8rem; display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" onchange="toggleCameraToggle('GreenScreen', this.checked)"> ç»¿å¹•
                        </label>
                        <label style="font-size: 0.8rem; display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" onchange="toggleCameraToggle('Streaming', this.checked)"> æ¨æµ
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- ç³»ç»Ÿä¿¡æ¯ -->
            <div class="panel category-system">
                <h2>â„¹ï¸ ç³»ç»Ÿä¿¡æ¯</h2>
                <div class="system-info" id="systemInfo">
                    <div class="system-item">
                        <span class="system-label">Avatar ID</span>
                        <span class="system-value avatar-id" id="systemAvatarId">-</span>
                    </div>
                    <div class="system-item">
                        <span class="system-label">VR Mode</span>
                        <span class="system-value" id="systemVRMode">-</span>
                    </div>
                    <div class="system-item">
                        <span class="system-label">Tracking Type</span>
                        <span class="system-value" id="systemTracking">-</span>
                    </div>
                    <div class="system-item">
                        <span class="system-label">Eye Height</span>
                        <span class="system-value" id="systemEyeHeight">-</span>
                    </div>
                </div>
            </div>
            
            <!-- Trackingä¿¡æ¯ -->
            <div class="panel category-tracking">
                <h2>ğŸ¯ è¿½è¸ªæ•°æ®</h2>
                <div class="system-info" id="trackingInfo">
                    <div class="system-item">
                        <span class="system-label">Head Pos</span>
                        <span class="system-value" id="trackingHeadPos">-</span>
                    </div>
                    <div class="system-item">
                        <span class="system-label">Head Rot</span>
                        <span class="system-value" id="trackingHeadRot">-</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Avatarå‚æ•°åŒº -->
        <div class="params-section">
            <div class="panel category-avatar">
                <h2>ğŸ­ Avatar Input æ§åˆ¶</h2>
                <div class="param-grid" id="avatarInputPanel"></div>
            </div>
            
            <div class="panel category-avatar">
                <h2>ğŸ“Š Avatar Output ç›‘æ§</h2>
                <div class="param-grid" id="avatarOutputPanel"></div>
            </div>
        </div>
        
        <!-- Velocityå¯è§†åŒ– -->
        <div class="vector-panel">
            <h2>ğŸ“ˆ Velocity å‘é‡å¯è§†åŒ– (X/Zå¹³é¢, æœ€å¤§è¾¹ç•Œ: 3m/s)</h2>
            <div class="vector-display">
                <canvas id="velocityCanvas" width="300" height="300"></canvas>
                <div class="vector-info">
                    <div class="vector-value">
                        <span class="vector-label">Velocity X (æ¨ªå‘):</span>
                        <span class="vector-num velocity-x" id="velX">0.000</span>
                    </div>
                    <div class="vector-value">
                        <span class="vector-label">Velocity Y (é«˜åº¦):</span>
                        <span class="vector-num velocity-y" id="velY">0.000</span>
                    </div>
                    <div class="vector-value">
                        <span class="vector-label">Velocity Z (çºµå‘):</span>
                        <span class="vector-num velocity-z" id="velZ">0.000</span>
                    </div>
                    <div class="vector-value">
                        <span class="vector-label">Magnitude:</span>
                        <span class="vector-num" id="velMag">0.000</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const parameters = {};
        let ws = null;
        const velocity = { x: 0, y: 0, z: 0, magnitude: 0 };
        
        // ===== WebSocketè¿æ¥ =====
        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
            
            ws.onopen = () => {
                document.getElementById('statusDot').classList.add('connected');
                document.getElementById('statusText').textContent = 'å·²è¿æ¥';
            };
            
            ws.onclose = () => {
                document.getElementById('statusDot').classList.remove('connected');
                document.getElementById('statusText').textContent = 'å·²æ–­å¼€ï¼Œé‡è¿ä¸­...';
                setTimeout(connect, 2000);
            };
            
            ws.onerror = (err) => {
                console.error('[WebSocket] Error:', err);
            };
            
            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    handleMessage(msg);
                } catch (e) {
                    console.error('[WebSocket] Invalid message:', e);
                }
            };
        }
        
        // ===== æ¶ˆæ¯å¤„ç† =====
        function handleMessage(msg) {
            switch(msg.type) {
                case 'init':
                    msg.parameters.forEach(p => {
                        parameters[p.name] = p;
                    });
                    renderUI();
                    break;
                    
                case 'output':
                    if (parameters[msg.name]) {
                        parameters[msg.name].value = msg.value;
                        updateOutput(msg);
                    }
                    break;
                    
                case 'input':
                    if (parameters[msg.name]) {
                        parameters[msg.name].value = msg.value;
                        updateInputUI(msg.name, msg.value);
                    }
                    break;
            }
        }
        
        // ===== æ›´æ–°è¾“å‡ºæ˜¾ç¤º =====
        function updateOutput(msg) {
            const { name, value, category } = msg;
            
            // ç³»ç»Ÿä¿¡æ¯
            if (category === 'system') {
                if (name === 'System_AvatarID') {
                    document.getElementById('systemAvatarId').textContent = value || '-';
                } else if (name === 'System_VRMode') {
                    document.getElementById('systemVRMode').textContent = value === 1 ? 'VR' : 'Desktop';
                } else if (name === 'System_TrackingType') {
                    const types = ['æ— ', 'HMD', 'HMD+æ‰‹', 'HMD+æ‰‹+èº«ä½“'];
                    document.getElementById('systemTracking').textContent = types[value] || value;
                } else if (name === 'System_EyeHeightAsMeters') {
                    document.getElementById('systemEyeHeight').textContent = value ? value.toFixed(2) + 'm' : '-';
                }
                return;
            }
            
            // Trackingæ•°æ®
            if (category === 'tracking') {
                updateTrackingDisplay();
                return;
            }
            
            // Avatarå‚æ•°
            const param = parameters[name];
            if (!param) return;
            
            // æ›´æ–°Velocity
            if (['VelocityX', 'VelocityY', 'VelocityZ', 'VelocityMagnitude'].includes(name)) {
                if (name === 'VelocityX') velocity.x = value;
                if (name === 'VelocityY') velocity.y = value;
                if (name === 'VelocityZ') velocity.z = value;
                if (name === 'VelocityMagnitude') velocity.magnitude = value;
                updateVelocityDisplay();
                return;
            }
            
            // æ›´æ–°UI
            if (param.type === 'Bool') {
                const indicator = document.getElementById(`out-${name}`);
                const valDisplay = document.getElementById(`val-out-${name}`);
                if (indicator) {
                    if (value === 1 || value === true) {
                        indicator.classList.add('active');
                    } else {
                        indicator.classList.remove('active');
                    }
                }
                if (valDisplay) valDisplay.textContent = (value === 1 || value === true) ? 'ON' : 'OFF';
            } else {
                const bar = document.getElementById(`bar-${name}`);
                const valDisplay = document.getElementById(`val-out-${name}`);
                
                if (valDisplay) valDisplay.textContent = typeof value === 'number' ? value.toFixed(3) : value;
                
                if (bar) {
                    const min = param.min || 0;
                    const max = param.max || 1;
                    const percent = ((value - min) / (max - min)) * 100;
                    bar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                }
            }
        }
        
        // ===== æ›´æ–°Trackingæ˜¾ç¤º =====
        function updateTrackingDisplay() {
            const headPos = ['Tracking_HeadPosX', 'Tracking_HeadPosY', 'Tracking_HeadPosZ']
                .map(n => parameters[n]?.value?.toFixed(2) || '0.00');
            const headRot = ['Tracking_HeadRotX', 'Tracking_HeadRotY', 'Tracking_HeadRotZ']
                .map(n => parameters[n]?.value?.toFixed(1) || '0.0');
            
            document.getElementById('trackingHeadPos').textContent = `X:${headPos[0]} Y:${headPos[1]} Z:${headPos[2]}`;
            document.getElementById('trackingHeadRot').textContent = `X:${headRot[0]}Â° Y:${headRot[1]}Â° Z:${headRot[2]}Â°`;
        }
        
        // ===== æ¸²æŸ“UI =====
        function renderUI() {
            const avatarInputPanel = document.getElementById('avatarInputPanel');
            const avatarOutputPanel = document.getElementById('avatarOutputPanel');
            
            avatarInputPanel.innerHTML = '';
            avatarOutputPanel.innerHTML = '';
            
            Object.values(parameters).forEach(param => {
                if (param.category === 'avatar') {
                    if (param.isInput) {
                        const el = createInputControl(param);
                        avatarInputPanel.appendChild(el);
                    }
                    if (param.isOutput) {
                        const el = createOutputDisplay(param);
                        avatarOutputPanel.appendChild(el);
                    }
                }
            });
        }
        
        // ===== åˆ›å»ºè¾“å…¥æ§ä»¶ =====
        function createInputControl(param) {
            const div = document.createElement('div');
            div.className = 'param-item';
            div.dataset.name = param.name;
            
            let controlHTML = '';
            
            if (param.type === 'Bool') {
                const checked = param.value ? 'checked' : '';
                controlHTML = `
                    <span class="param-name">${param.name}</span>
                    <span class="param-type">${param.type}</span>
                    <label class="switch">
                        <input type="checkbox" ${checked} onchange="sendParamValue('${param.name}', this.checked ? 1 : 0)">
                        <span class="slider-switch"></span>
                    </label>
                `;
            } else {
                const min = param.min !== undefined ? param.min : 0;
                const max = param.max !== undefined ? param.max : (param.type === 'Int' ? 8 : 1);
                const step = param.type === 'Int' ? 1 : 0.01;
                const value = param.value !== null ? param.value : min;
                
                controlHTML = `
                    <span class="param-name">${param.name}</span>
                    <span class="param-type">${param.type}</span>
                    <div class="slider-container">
                        <input type="range" min="${min}" max="${max}" step="${step}" 
                               value="${value}" 
                               oninput="handleSliderChange('${param.name}', this.value, '${param.type}')">
                        <span class="value-display" id="val-${param.name}">${value}</span>
                    </div>
                `;
            }
            
            div.innerHTML = controlHTML;
            return div;
        }
        
        // ===== åˆ›å»ºè¾“å‡ºæ˜¾ç¤º =====
        function createOutputDisplay(param) {
            const div = document.createElement('div');
            div.className = 'param-item';
            div.dataset.name = param.name;
            
            let displayHTML = '';
            
            if (param.type === 'Bool') {
                const active = param.value ? 'active' : '';
                displayHTML = `
                    <span class="param-name">${param.name}</span>
                    <span class="param-type">${param.type}</span>
                    <div class="bool-indicator ${active}" id="out-${param.name}"></div>
                    <span class="output-value" id="val-out-${param.name}">${param.value ? 'ON' : 'OFF'}</span>
                `;
            } else {
                const value = param.value !== null ? param.value.toFixed(3) : '0.000';
                const min = param.min || 0;
                const max = param.max || 1;
                const percent = param.value !== null 
                    ? ((param.value - min) / (max - min) * 100) 
                    : 0;
                
                displayHTML = `
                    <span class="param-name">${param.name}</span>
                    <span class="param-type">${param.type}</span>
                    <div class="progress-bar">
                        <div class="progress-fill" id="bar-${param.name}" style="width: ${Math.max(0, Math.min(100, percent))}%"></div>
                    </div>
                    <span class="output-value" id="val-out-${param.name}">${value}</span>
                `;
            }
            
            div.innerHTML = displayHTML;
            return div;
        }
        
        // ===== æ»‘å—å¤„ç† =====
        function handleSliderChange(name, value, type) {
            document.getElementById(`val-${name}`).textContent = value;
            const numValue = type === 'Int' ? parseInt(value) : parseFloat(value);
            sendParamValue(name, numValue);
        }
        
        function updateInputUI(name, value) {
            const param = parameters[name];
            if (!param || param.category !== 'avatar') return;
            
            const item = document.querySelector(`.param-item[data-name="${name}"]`);
            if (!item) return;
            
            if (param.type === 'Bool') {
                const checkbox = item.querySelector('input[type="checkbox"]');
                if (checkbox) checkbox.checked = value === 1 || value === true;
            } else {
                const slider = item.querySelector('input[type="range"]');
                const display = item.querySelector('.value-display');
                if (slider) slider.value = value;
                if (display) display.textContent = value;
            }
        }
        
        // ===== å‘é€å‚æ•°å€¼ =====
        function sendParamValue(name, value) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'set', name: name, value: value }));
            }
        }
        
        // ===== Inputæ§åˆ¶ =====
        function sendInput(action, value) {
            const paramName = `Input_${action}`;
            if (parameters[paramName]) {
                sendParamValue(paramName, value);
            }
        }
        
        // ç´§æ€¥åœæ­¢ç§»åŠ¨
        function stopMovement() {
            console.log('[Emergency Stop] Stopping all movement');
            
            // é‡ç½®æ‘‡æ†çŠ¶æ€
            if (joystick) {
                joystick.isDragging = false;
                joystick.x = 0;
                joystick.y = 0;
                joystick.draw();
                document.getElementById('joyX').textContent = '0.00';
                document.getElementById('joyY').textContent = '0.00';
            }
            
            // å‘é€0å€¼åœæ­¢ç§»åŠ¨
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'set', name: 'Input_Horizontal', value: 0 }));
                ws.send(JSON.stringify({ type: 'set', name: 'Input_Vertical', value: 0 }));
                ws.send(JSON.stringify({ type: 'set', name: 'Input_MoveForward', value: false }));
                ws.send(JSON.stringify({ type: 'set', name: 'Input_MoveBackward', value: false }));
                ws.send(JSON.stringify({ type: 'set', name: 'Input_MoveLeft', value: false }));
                ws.send(JSON.stringify({ type: 'set', name: 'Input_MoveRight', value: false }));
            }
            
            // æ˜¾ç¤ºæç¤º
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'âœ“ å·²åœæ­¢';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 1000);
        }
        
        function toggleInput(action) {
            const paramName = `Input_${action}`;
            if (parameters[paramName]) {
                const current = parameters[paramName].value;
                sendParamValue(paramName, current ? false : true);
            }
        }
        
        // ===== Chatbox =====
        function sendChatbox() {
            const text = document.getElementById('chatboxText').value.trim();
            if (!text) return;
            
            const notification = document.getElementById('chatboxNotify').checked;
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'chatbox',
                    text: text,
                    send: true,
                    notification: notification
                }));
                
                document.getElementById('chatboxText').value = '';
            }
        }
        
        // Enterå‘é€
        document.getElementById('chatboxText')?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatbox();
            }
        });
        
        // ===== ç›¸æœºæ§åˆ¶ =====
        function setCameraMode(mode) {
            sendParamValue('Camera_Mode', parseInt(mode));
        }
        
        function sendCameraAction(action) {
            sendParamValue(`Camera_${action}`, true);
        }
        
        function setCameraParam(param, value) {
            document.getElementById(`${param.toLowerCase()}Value`).textContent = value;
            sendParamValue(`Camera_${param}`, parseFloat(value));
        }
        
        function toggleCameraToggle(param, value) {
            sendParamValue(`Camera_${param}`, value);
        }
        
        // ===== è™šæ‹Ÿæ‘‡æ† =====
        class VirtualJoystick {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                this.radius = 70;
                this.knobRadius = 25;
                this.x = 0;
                this.y = 0;
                this.isDragging = false;
                this.touchId = null;
                this.lastSentX = null;
                this.lastSentY = null;
                this.heartbeatInterval = null;
                
                this.setupEvents();
                this.startHeartbeat();
                this.draw();
            }
            
            startHeartbeat() {
                // VRChatéœ€è¦æŒç»­æ¥æ”¶Inputå€¼ï¼Œæ¯50mså‘é€ä¸€æ¬¡å¿ƒè·³
                this.heartbeatInterval = setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // åªæœ‰å½“å€¼æœ‰å˜åŒ–æˆ–è€…æ˜¯0å€¼æ—¶æ‰å‘é€
                        const normalizedX = parseFloat((this.x / this.radius).toFixed(3));
                        const normalizedY = parseFloat((-this.y / this.radius).toFixed(3));
                        
                        const finalX = Math.abs(normalizedX) < 0.001 ? 0.0 : normalizedX;
                        const finalY = Math.abs(normalizedY) < 0.001 ? 0.0 : normalizedY;
                        
                        // å¦‚æœå€¼å˜åŒ–äº†ï¼Œæˆ–è€…æ˜¯éé›¶å€¼éœ€è¦æŒç»­å‘é€
                        if (finalX !== this.lastSentX || finalY !== this.lastSentY || finalX !== 0.0 || finalY !== 0.0) {
                            this.sendDirectValues(finalX, finalY);
                            this.lastSentX = finalX;
                            this.lastSentY = finalY;
                        }
                    }
                }, 50); // 20Hzæ›´æ–°ç‡
            }
            
            sendDirectValues(x, y) {
                if (parameters['Input_Horizontal']) {
                    ws.send(JSON.stringify({
                        type: 'set',
                        name: 'Input_Horizontal',
                        value: x
                    }));
                }
                if (parameters['Input_Vertical']) {
                    ws.send(JSON.stringify({
                        type: 'set',
                        name: 'Input_Vertical',
                        value: y
                    }));
                }
            }
            
            setupEvents() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => this.start(e.offsetX, e.offsetY));
                window.addEventListener('mousemove', (e) => this.move(e));
                window.addEventListener('mouseup', () => this.end());
                // é¼ æ ‡ç¦»å¼€ç”»å¸ƒæ—¶åœæ­¢
                this.canvas.addEventListener('mouseleave', () => this.end());
                // çª—å£å¤±å»ç„¦ç‚¹æ—¶åœæ­¢
                window.addEventListener('blur', () => this.end());
                
                // è§¦æ‘¸äº‹ä»¶
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.start(touch.clientX - rect.left, touch.clientY - rect.top);
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.moveTouch(touch.clientX - rect.left, touch.clientY - rect.top);
                }, { passive: false });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.end();
                });
                
                // è§¦æ‘¸å–æ¶ˆæ—¶åœæ­¢
                this.canvas.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.end();
                });
            }
            
            start(x, y) {
                this.isDragging = true;
                this.updatePosition(x, y);
            }
            
            move(e) {
                if (!this.isDragging) return;
                const rect = this.canvas.getBoundingClientRect();
                this.updatePosition(e.clientX - rect.left, e.clientY - rect.top);
            }
            
            moveTouch(x, y) {
                if (!this.isDragging) return;
                this.updatePosition(x, y);
            }
            
            updatePosition(x, y) {
                const dx = x - this.centerX;
                const dy = y - this.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > this.radius) {
                    const angle = Math.atan2(dy, dx);
                    this.x = Math.cos(angle) * this.radius;
                    this.y = Math.sin(angle) * this.radius;
                } else {
                    this.x = dx;
                    this.y = dy;
                }
                
                this.sendValues();
                this.draw();
            }
            
            end() {
                this.isDragging = false;
                this.x = 0;
                this.y = 0;
                
                // ç«‹å³å‘é€0å€¼ï¼ˆé€šè¿‡å¿ƒè·³æœºåˆ¶ä¼šç»§ç»­ä¿æŒï¼‰
                this.lastSentX = null; // å¼ºåˆ¶ä¸‹ä¸€æ¬¡å¿ƒè·³å‘é€
                this.lastSentY = null;
                this.sendDirectValues(0.0, 0.0);
                
                this.draw();
            }
            
            destroy() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                }
            }
            
            sendValues() {
                // å½’ä¸€åŒ–åˆ° -1.0 ~ 1.0ï¼Œå¹¶ç¡®ä¿0å€¼ç²¾ç¡®
                let normalizedX = parseFloat((this.x / this.radius).toFixed(3));
                let normalizedY = parseFloat((-this.y / this.radius).toFixed(3)); // Yè½´ç¿»è½¬
                
                // é˜²æ­¢-0çš„æƒ…å†µ
                if (Math.abs(normalizedX) < 0.001) normalizedX = 0;
                if (Math.abs(normalizedY) < 0.001) normalizedY = 0;
                
                document.getElementById('joyX').textContent = normalizedX.toFixed(2);
                document.getElementById('joyY').textContent = normalizedY.toFixed(2);
                
                // å‘é€Input_Horizontalå’ŒInput_Vertical
                if (parameters['Input_Horizontal'] && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'set',
                        name: 'Input_Horizontal',
                        value: normalizedX
                    }));
                }
                if (parameters['Input_Vertical'] && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'set',
                        name: 'Input_Vertical',
                        value: normalizedY
                    }));
                }
                
                // è°ƒè¯•æ—¥å¿—
                console.log(`[Joystick] X: ${normalizedX}, Y: ${normalizedY}`);
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // å¤–åœˆ
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
                this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // åå­—çº¿
                this.ctx.beginPath();
                this.ctx.moveTo(this.centerX - this.radius, this.centerY);
                this.ctx.lineTo(this.centerX + this.radius, this.centerY);
                this.ctx.moveTo(this.centerX, this.centerY - this.radius);
                this.ctx.lineTo(this.centerX, this.centerY + this.radius);
                this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
                
                // æ‘‡æ†å¤´
                this.ctx.beginPath();
                this.ctx.arc(this.centerX + this.x, this.centerY + this.y, this.knobRadius, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 212, 255, 0.6)';
                this.ctx.fill();
                
                // å‘å…‰æ•ˆæœ
                this.ctx.beginPath();
                this.ctx.arc(this.centerX + this.x, this.centerY + this.y, this.knobRadius + 5, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 212, 255, 0.2)';
                this.ctx.fill();
            }
        }
        
        // ===== Velocityå¯è§†åŒ– =====
        function updateVelocityDisplay() {
            document.getElementById('velX').textContent = velocity.x.toFixed(3);
            document.getElementById('velY').textContent = velocity.y.toFixed(3);
            document.getElementById('velZ').textContent = velocity.z.toFixed(3);
            document.getElementById('velMag').textContent = velocity.magnitude.toFixed(3);
            
            drawVelocityVector();
        }
        
        function drawVelocityVector() {
            const canvas = document.getElementById('velocityCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, w, h);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            const maxBound = 3;
            const scale = 130 / maxBound;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            for (let i = 1; i <= 3; i++) {
                const r = i * scale;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillText(i.toString(), cx + r + 2, cy - 2);
            }
            
            ctx.beginPath();
            ctx.moveTo(cx, 20);
            ctx.lineTo(cx, h - 20);
            ctx.moveTo(20, cy);
            ctx.lineTo(w - 20, cy);
            ctx.stroke();
            
            ctx.fillStyle = '#00d4ff';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('X', w - 35, cy + 5);
            ctx.fillText('-X', 25, cy + 5);
            
            ctx.fillStyle = '#ff6b6b';
            ctx.textAlign = 'center';
            ctx.fillText('-Z', cx, 35);
            ctx.fillText('Z', cx, h - 15);
            
            const vx = velocity.x * scale;
            const vy = -velocity.z * scale;
            
            ctx.strokeStyle = '#00ff88';
            ctx.fillStyle = '#00ff88';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + vx, cy + vy);
            ctx.stroke();
            
            const angle = Math.atan2(vy, vx);
            const headLen = 10;
            ctx.beginPath();
            ctx.moveTo(cx + vx, cy + vy);
            ctx.lineTo(cx + vx - headLen * Math.cos(angle - Math.PI / 6), cy + vy - headLen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(cx + vx, cy + vy);
            ctx.lineTo(cx + vx - headLen * Math.cos(angle + Math.PI / 6), cy + vy - headLen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            
            if (velocity.magnitude > 0.01) {
                ctx.beginPath();
                ctx.arc(cx + vx, cy + vy, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#00ff88';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(cx + vx, cy + vy, 12, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                ctx.fill();
            }
        }
        
        // ===== åˆå§‹åŒ– =====
        let joystick;
        
        window.onload = () => {
            connect();
            joystick = new VirtualJoystick('joystickCanvas');
            drawVelocityVector();
        };
        
        // é¡µé¢å…³é—­/åˆ·æ–°æ—¶å‘é€åœæ­¢ä¿¡å·
        window.addEventListener('beforeunload', () => {
            if (joystick) {
                joystick.destroy();
            }
            // åŒæ­¥å‘é€åœæ­¢ä¿¡å·
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'set', name: 'Input_Horizontal', value: 0.0 }));
                ws.send(JSON.stringify({ type: 'set', name: 'Input_Vertical', value: 0.0 }));
            }
        });
        
        // é¡µé¢éšè—æ—¶å‘é€åœæ­¢ä¿¡å·
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && joystick) {
                joystick.end();
            }
        });
    </script>
</body>
</html>